/* tslint:disable */
/* eslint-disable */

// ######################################## THIS FILE WAS GENERATED BY MONGOOSE-TSGEN ######################################## //

// NOTE: ANY CHANGES MADE WILL BE OVERWRITTEN ON SUBSEQUENT EXECUTIONS OF MONGOOSE-TSGEN.

import mongoose from 'mongoose';

/**
 * Lean version of appointmentDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `appointmentDocument.toObject()`. To avoid conflicts with model names, use the type alias `appointmentObject`.
 * ```
 * const appointmentObject = appointment.toObject();
 * ```
 */
export type appointment = {
  appointment_no: string;
  mrn: string;
  doctor: employee['_id'] | employee;
  unit: unit['_id'] | unit;
  time: string;
  que_no: string;
  date: Date;
  method: 'WHATSAPP' | 'TELEPON' | 'DI TEMPAT' | 'PERMINTAAN' | 'PIHAK KETIGA';
  visit_type: 'KONSULTASI' | 'KONTROL';
  guarantor?: string;
  guarantor_no?: string;
  status: 'BATAL' | 'KADALUARSA' | 'SUDAH REGISTRASI' | 'BELUM REGISTRASI';
  created_at: Date;
  created_by: employee['_id'] | employee;
  updated_at?: Date;
  updated_by?: employee['_id'] | employee;
  canceled_at?: Date;
  canceled_by?: employee['_id'] | employee;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of appointmentDocument (type alias of `appointment`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { appointment } from "../models"
 * import { appointmentObject } from "../interfaces/mongoose.gen.ts"
 *
 * const appointmentObject: appointmentObject = appointment.toObject();
 * ```
 */
export type appointmentObject = appointment;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type appointmentQuery = mongoose.Query<
  any,
  appointmentDocument,
  appointmentQueries
> &
  appointmentQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `appointmentSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type appointmentQueries = {};

export type appointmentMethods = {};

export type appointmentStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const appointment = mongoose.model<appointmentDocument, appointmentModel>("appointment", appointmentSchema);
 * ```
 */
export type appointmentModel = mongoose.Model<
  appointmentDocument,
  appointmentQueries
> &
  appointmentStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new appointment schema instances:
 * ```
 * const appointmentSchema: appointmentSchema = new mongoose.Schema({ ... })
 * ```
 */
export type appointmentSchema = mongoose.Schema<
  appointmentDocument,
  appointmentModel,
  appointmentMethods,
  appointmentQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const appointment = mongoose.model<appointmentDocument, appointmentModel>("appointment", appointmentSchema);
 * ```
 */
export type appointmentDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  appointmentQueries
> &
  appointmentMethods & {
    appointment_no: string;
    mrn: string;
    doctor: employeeDocument['_id'] | employeeDocument;
    unit: unitDocument['_id'] | unitDocument;
    time: string;
    que_no: string;
    date: Date;
    method:
      | 'WHATSAPP'
      | 'TELEPON'
      | 'DI TEMPAT'
      | 'PERMINTAAN'
      | 'PIHAK KETIGA';
    visit_type: 'KONSULTASI' | 'KONTROL';
    guarantor?: string;
    guarantor_no?: string;
    status: 'BATAL' | 'KADALUARSA' | 'SUDAH REGISTRASI' | 'BELUM REGISTRASI';
    created_at: Date;
    created_by: employeeDocument['_id'] | employeeDocument;
    updated_at?: Date;
    updated_by?: employeeDocument['_id'] | employeeDocument;
    canceled_at?: Date;
    canceled_by?: employeeDocument['_id'] | employeeDocument;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of employeeNameDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `employeeDocument.toObject()`.
 * ```
 * const employeeObject = employee.toObject();
 * ```
 */
export type employeeName = {
  _id: {
    type: {};
  };
  prefix?: string;
  first: string;
  middle?: string;
  last: string;
  suffix?: string;
};

/**
 * Lean version of employeeAccountDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `employeeDocument.toObject()`.
 * ```
 * const employeeObject = employee.toObject();
 * ```
 */
export type employeeAccount = {
  has_account: boolean;
  account_id?: string;
  account_email?: string;
  account_role?: string;
  registered_at?: Date;
  registered_by?: employee['_id'] | employee;
  _id: {
    type: {};
  };
};

/**
 * Lean version of employeeDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `employeeDocument.toObject()`. To avoid conflicts with model names, use the type alias `employeeObject`.
 * ```
 * const employeeObject = employee.toObject();
 * ```
 */
export type employee = {
  organization: organization['_id'] | organization;
  position?: string;
  type: 'DOKTER TETAP' | 'DOKTER BERKUNJUNG' | 'PERAWAT' | 'STAF';
  created_at: Date;
  created_by: employee['_id'] | employee;
  updated_at?: Date;
  updated_by?: employee['_id'] | employee;
  _id: mongoose.Types.ObjectId;
  name: employeeName;
  account: employeeAccount;
};

/**
 * Lean version of employeeDocument (type alias of `employee`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { employee } from "../models"
 * import { employeeObject } from "../interfaces/mongoose.gen.ts"
 *
 * const employeeObject: employeeObject = employee.toObject();
 * ```
 */
export type employeeObject = employee;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type employeeQuery = mongoose.Query<
  any,
  employeeDocument,
  employeeQueries
> &
  employeeQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `employeeSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type employeeQueries = {};

export type employeeMethods = {};

export type employeeStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const employee = mongoose.model<employeeDocument, employeeModel>("employee", employeeSchema);
 * ```
 */
export type employeeModel = mongoose.Model<employeeDocument, employeeQueries> &
  employeeStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new employee schema instances:
 * ```
 * const employeeSchema: employeeSchema = new mongoose.Schema({ ... })
 * ```
 */
export type employeeSchema = mongoose.Schema<
  employeeDocument,
  employeeModel,
  employeeMethods,
  employeeQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const employee = mongoose.model<employeeDocument, employeeModel>("employee", employeeSchema);
 * ```
 */
export type employeeNameDocument =
  mongoose.Document<mongoose.Types.ObjectId> & {
    _id: {
      type: {};
    };
    prefix?: string;
    first: string;
    middle?: string;
    last: string;
    suffix?: string;
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const employee = mongoose.model<employeeDocument, employeeModel>("employee", employeeSchema);
 * ```
 */
export type employeeAccountDocument =
  mongoose.Document<mongoose.Types.ObjectId> & {
    has_account: boolean;
    account_id?: string;
    account_email?: string;
    account_role?: string;
    registered_at?: Date;
    registered_by?: employeeDocument['_id'] | employeeDocument;
    _id: {
      type: {};
    };
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const employee = mongoose.model<employeeDocument, employeeModel>("employee", employeeSchema);
 * ```
 */
export type employeeDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  employeeQueries
> &
  employeeMethods & {
    organization: organizationDocument['_id'] | organizationDocument;
    position?: string;
    type: 'DOKTER TETAP' | 'DOKTER BERKUNJUNG' | 'PERAWAT' | 'STAF';
    created_at: Date;
    created_by: employeeDocument['_id'] | employeeDocument;
    updated_at?: Date;
    updated_by?: employeeDocument['_id'] | employeeDocument;
    _id: mongoose.Types.ObjectId;
    name: employeeNameDocument;
    account: employeeAccountDocument;
  };

/**
 * Lean version of entityEmployeeDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `entityEmployeeDocument.toObject()`. To avoid conflicts with model names, use the type alias `entityEmployeeObject`.
 * ```
 * const entityemployeeObject = entityemployee.toObject();
 * ```
 */
export type entityEmployee = {
  entity: entity['_id'] | entity;
  employees: (employee['_id'] | employee)[];
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of entityEmployeeDocument (type alias of `entityEmployee`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { entityEmployee } from "../models"
 * import { entityEmployeeObject } from "../interfaces/mongoose.gen.ts"
 *
 * const entityemployeeObject: entityEmployeeObject = entityemployee.toObject();
 * ```
 */
export type entityEmployeeObject = entityEmployee;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type entityEmployeeQuery = mongoose.Query<
  any,
  entityEmployeeDocument,
  entityEmployeeQueries
> &
  entityEmployeeQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `entityEmployeeSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type entityEmployeeQueries = {};

export type entityEmployeeMethods = {};

export type entityEmployeeStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const entityEmployee = mongoose.model<entityEmployeeDocument, entityEmployeeModel>("entityEmployee", entityEmployeeSchema);
 * ```
 */
export type entityEmployeeModel = mongoose.Model<
  entityEmployeeDocument,
  entityEmployeeQueries
> &
  entityEmployeeStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new entityEmployee schema instances:
 * ```
 * const entityEmployeeSchema: entityEmployeeSchema = new mongoose.Schema({ ... })
 * ```
 */
export type entityEmployeeSchema = mongoose.Schema<
  entityEmployeeDocument,
  entityEmployeeModel,
  entityEmployeeMethods,
  entityEmployeeQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const entityEmployee = mongoose.model<entityEmployeeDocument, entityEmployeeModel>("entityEmployee", entityEmployeeSchema);
 * ```
 */
export type entityEmployeeDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  entityEmployeeQueries
> &
  entityEmployeeMethods & {
    entity: entityDocument['_id'] | entityDocument;
    employees: mongoose.Types.Array<employeeDocument['_id'] | employeeDocument>;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of entityAddressDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `entityDocument.toObject()`.
 * ```
 * const entityObject = entity.toObject();
 * ```
 */
export type entityAddress = {
  street: string;
  subdistrict: string;
  district: string;
  city: string;
  province?: string;
  zipcode?: string;
  _id: {
    type: {};
  };
};

/**
 * Lean version of entityWarehouseDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `entityDocument.toObject()`.
 * ```
 * const entityObject = entity.toObject();
 * ```
 */
export type entityWarehouse = {
  _id: {
    type: {};
  };
  storage_type:
    | 'PASOKAN MEDIS'
    | 'PASOKAN NON - MEDIS '
    | 'MAKANAN MENTAH '
    | 'MAKANAN OLAHAN '
    | 'LAINNYA '
    | 'SEMUA ';
};

/**
 * Lean version of entityMedicalDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `entityDocument.toObject()`.
 * ```
 * const entityObject = entity.toObject();
 * ```
 */
export type entityMedical = {
  _id: {
    type: {};
  };
  is_main_branch: boolean;
};

/**
 * Lean version of entityDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `entityDocument.toObject()`. To avoid conflicts with model names, use the type alias `entityObject`.
 * ```
 * const entityObject = entity.toObject();
 * ```
 */
export type entity = {
  organization: organization['_id'] | organization;
  name: string;
  about?: string;
  type: 'GUDANG' | 'MEDIS';
  status: 'BUKA' | 'TUTUP' | 'PEMELIHARAAN';
  is_address_same_as_org: boolean;
  created_at: Date;
  created_by: employee['_id'] | employee;
  updated_at?: Date;
  updated_by?: employee['_id'] | employee;
  _id: mongoose.Types.ObjectId;
  address: entityAddress;
  warehouse?: entityWarehouse;
  medical?: entityMedical;
};

/**
 * Lean version of entityDocument (type alias of `entity`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { entity } from "../models"
 * import { entityObject } from "../interfaces/mongoose.gen.ts"
 *
 * const entityObject: entityObject = entity.toObject();
 * ```
 */
export type entityObject = entity;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type entityQuery = mongoose.Query<any, entityDocument, entityQueries> &
  entityQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `entitySchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type entityQueries = {};

export type entityMethods = {};

export type entityStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const entity = mongoose.model<entityDocument, entityModel>("entity", entitySchema);
 * ```
 */
export type entityModel = mongoose.Model<entityDocument, entityQueries> &
  entityStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new entity schema instances:
 * ```
 * const entitySchema: entitySchema = new mongoose.Schema({ ... })
 * ```
 */
export type entitySchema = mongoose.Schema<
  entityDocument,
  entityModel,
  entityMethods,
  entityQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const entity = mongoose.model<entityDocument, entityModel>("entity", entitySchema);
 * ```
 */
export type entityAddressDocument =
  mongoose.Document<mongoose.Types.ObjectId> & {
    street: string;
    subdistrict: string;
    district: string;
    city: string;
    province?: string;
    zipcode?: string;
    _id: {
      type: {};
    };
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const entity = mongoose.model<entityDocument, entityModel>("entity", entitySchema);
 * ```
 */
export type entityWarehouseDocument =
  mongoose.Document<mongoose.Types.ObjectId> & {
    _id: {
      type: {};
    };
    storage_type:
      | 'PASOKAN MEDIS'
      | 'PASOKAN NON - MEDIS '
      | 'MAKANAN MENTAH '
      | 'MAKANAN OLAHAN '
      | 'LAINNYA '
      | 'SEMUA ';
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const entity = mongoose.model<entityDocument, entityModel>("entity", entitySchema);
 * ```
 */
export type entityMedicalDocument =
  mongoose.Document<mongoose.Types.ObjectId> & {
    _id: {
      type: {};
    };
    is_main_branch: boolean;
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const entity = mongoose.model<entityDocument, entityModel>("entity", entitySchema);
 * ```
 */
export type entityDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  entityQueries
> &
  entityMethods & {
    organization: organizationDocument['_id'] | organizationDocument;
    name: string;
    about?: string;
    type: 'GUDANG' | 'MEDIS';
    status: 'BUKA' | 'TUTUP' | 'PEMELIHARAAN';
    is_address_same_as_org: boolean;
    created_at: Date;
    created_by: employeeDocument['_id'] | employeeDocument;
    updated_at?: Date;
    updated_by?: employeeDocument['_id'] | employeeDocument;
    _id: mongoose.Types.ObjectId;
    address: entityAddressDocument;
    warehouse?: entityWarehouseDocument;
    medical?: entityMedicalDocument;
  };

/**
 * Lean version of guarantorDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `guarantorDocument.toObject()`. To avoid conflicts with model names, use the type alias `guarantorObject`.
 * ```
 * const guarantorObject = guarantor.toObject();
 * ```
 */
export type guarantor = {
  name: string;
  type: 'PRIBADI' | 'ASURANSI' | 'KORPORASI';
  contract: {
    start: Date;
    end: Date;
  };
  created_at: Date;
  created_by: employee['_id'] | employee;
  updated_at?: Date;
  updated_by?: employee['_id'] | employee;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of guarantorDocument (type alias of `guarantor`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { guarantor } from "../models"
 * import { guarantorObject } from "../interfaces/mongoose.gen.ts"
 *
 * const guarantorObject: guarantorObject = guarantor.toObject();
 * ```
 */
export type guarantorObject = guarantor;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type guarantorQuery = mongoose.Query<
  any,
  guarantorDocument,
  guarantorQueries
> &
  guarantorQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `guarantorSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type guarantorQueries = {};

export type guarantorMethods = {};

export type guarantorStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const guarantor = mongoose.model<guarantorDocument, guarantorModel>("guarantor", guarantorSchema);
 * ```
 */
export type guarantorModel = mongoose.Model<
  guarantorDocument,
  guarantorQueries
> &
  guarantorStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new guarantor schema instances:
 * ```
 * const guarantorSchema: guarantorSchema = new mongoose.Schema({ ... })
 * ```
 */
export type guarantorSchema = mongoose.Schema<
  guarantorDocument,
  guarantorModel,
  guarantorMethods,
  guarantorQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const guarantor = mongoose.model<guarantorDocument, guarantorModel>("guarantor", guarantorSchema);
 * ```
 */
export type guarantorDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  guarantorQueries
> &
  guarantorMethods & {
    name: string;
    type: 'PRIBADI' | 'ASURANSI' | 'KORPORASI';
    contract: {
      start: Date;
      end: Date;
    };
    created_at: Date;
    created_by: employeeDocument['_id'] | employeeDocument;
    updated_at?: Date;
    updated_by?: employeeDocument['_id'] | employeeDocument;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of organizationContact_personDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `organizationDocument.toObject()`.
 * ```
 * const organizationObject = organization.toObject();
 * ```
 */
export type organizationContact_person = {
  _id: {
    type: {};
  };
  name?: string;
  ssn?: string;
  relation?:
    | 'BAPAK'
    | 'IBU'
    | 'ANAK'
    | 'SAUDARA KANDUNG'
    | 'SUAMI'
    | 'ISTRI'
    | 'KAKEK'
    | 'NENEK'
    | 'KERABAT';
  email: string;
  phone_number: string[];
};

/**
 * Lean version of organizationAddressDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `organizationDocument.toObject()`.
 * ```
 * const organizationObject = organization.toObject();
 * ```
 */
export type organizationAddress = {
  street: string;
  subdistrict: string;
  district: string;
  city: string;
  province?: string;
  zipcode?: string;
  _id: {
    type: {};
  };
};

/**
 * Lean version of organizationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `organizationDocument.toObject()`. To avoid conflicts with model names, use the type alias `organizationObject`.
 * ```
 * const organizationObject = organization.toObject();
 * ```
 */
export type organization = {
  name: string;
  about?: string;
  logo?: string;
  subscription_plan: string;
  status: 'AKTIF' | 'DITANGGUHKAN';
  registered_at: Date;
  _id: mongoose.Types.ObjectId;
  contact_person: organizationContact_person;
  address: organizationAddress;
};

/**
 * Lean version of organizationDocument (type alias of `organization`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { organization } from "../models"
 * import { organizationObject } from "../interfaces/mongoose.gen.ts"
 *
 * const organizationObject: organizationObject = organization.toObject();
 * ```
 */
export type organizationObject = organization;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type organizationQuery = mongoose.Query<
  any,
  organizationDocument,
  organizationQueries
> &
  organizationQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `organizationSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type organizationQueries = {};

export type organizationMethods = {};

export type organizationStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const organization = mongoose.model<organizationDocument, organizationModel>("organization", organizationSchema);
 * ```
 */
export type organizationModel = mongoose.Model<
  organizationDocument,
  organizationQueries
> &
  organizationStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new organization schema instances:
 * ```
 * const organizationSchema: organizationSchema = new mongoose.Schema({ ... })
 * ```
 */
export type organizationSchema = mongoose.Schema<
  organizationDocument,
  organizationModel,
  organizationMethods,
  organizationQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const organization = mongoose.model<organizationDocument, organizationModel>("organization", organizationSchema);
 * ```
 */
export type organizationContact_personDocument =
  mongoose.Document<mongoose.Types.ObjectId> & {
    _id: {
      type: {};
    };
    name?: string;
    ssn?: string;
    relation?:
      | 'BAPAK'
      | 'IBU'
      | 'ANAK'
      | 'SAUDARA KANDUNG'
      | 'SUAMI'
      | 'ISTRI'
      | 'KAKEK'
      | 'NENEK'
      | 'KERABAT';
    email: string;
    phone_number: mongoose.Types.Array<string>;
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const organization = mongoose.model<organizationDocument, organizationModel>("organization", organizationSchema);
 * ```
 */
export type organizationAddressDocument =
  mongoose.Document<mongoose.Types.ObjectId> & {
    street: string;
    subdistrict: string;
    district: string;
    city: string;
    province?: string;
    zipcode?: string;
    _id: {
      type: {};
    };
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const organization = mongoose.model<organizationDocument, organizationModel>("organization", organizationSchema);
 * ```
 */
export type organizationDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  organizationQueries
> &
  organizationMethods & {
    name: string;
    about?: string;
    logo?: string;
    subscription_plan: string;
    status: 'AKTIF' | 'DITANGGUHKAN';
    registered_at: Date;
    _id: mongoose.Types.ObjectId;
    contact_person: organizationContact_personDocument;
    address: organizationAddressDocument;
  };

/**
 * Lean version of patientNameDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `patientDocument.toObject()`.
 * ```
 * const patientObject = patient.toObject();
 * ```
 */
export type patientName = {
  _id: {
    type: {};
  };
  prefix?: string;
  first: string;
  middle?: string;
  last: string;
  suffix?: string;
};

/**
 * Lean version of patientAdditional_dataDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `patientDocument.toObject()`.
 * ```
 * const patientObject = patient.toObject();
 * ```
 */
export type patientAdditional_data = {
  _id: {
    type: {};
  };
  dob?: Date;
  pob?: string;
  address: {
    street: string;
    subdistrict: string;
    district: string;
    city: string;
    province?: string;
    zipcode?: string;
  };
  temporary_address: {
    street: string;
    subdistrict: string;
    district: string;
    city: string;
    province?: string;
    zipcode?: string;
  };
  contact: {
    name?: string;
    ssn?: string;
    relation?:
      | 'BAPAK'
      | 'IBU'
      | 'ANAK'
      | 'SAUDARA KANDUNG'
      | 'SUAMI'
      | 'ISTRI'
      | 'KAKEK'
      | 'NENEK'
      | 'KERABAT';
    email: string;
    phone_number: string[];
  };
  emergency_contact: {
    name?: string;
    ssn?: string;
    relation?:
      | 'BAPAK'
      | 'IBU'
      | 'ANAK'
      | 'SAUDARA KANDUNG'
      | 'SUAMI'
      | 'ISTRI'
      | 'KAKEK'
      | 'NENEK'
      | 'KERABAT';
    email: string;
    phone_number: string[];
  };
  status: {
    is_blacklisted: boolean;
    is_alive: boolean;
    deceased_at?: Date;
  };
  notes?: string;
  guarantor: guarantor['_id'] | guarantor;
  guarantor_no?: string;
};

/**
 * Lean version of patientDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `patientDocument.toObject()`. To avoid conflicts with model names, use the type alias `patientObject`.
 * ```
 * const patientObject = patient.toObject();
 * ```
 */
export type patient = {
  mrn: string;
  ssn: string;
  religion:
    | 'ISLAM'
    | 'PROTESTAN'
    | 'KATHOLIK'
    | 'HINDU'
    | 'BUDDHA'
    | 'KHONGHUCU';
  occupation: string;
  education: string;
  marital_status: 'BELUM MENIKAH' | 'MENIKAH' | 'CERAI MATI' | 'CERAI HIDUP';
  created_at: Date;
  created_by: employee['_id'] | employee;
  updated_at?: Date;
  updated_by?: employee['_id'] | employee;
  _id: mongoose.Types.ObjectId;
  name: patientName;
  additional_data: patientAdditional_data;
};

/**
 * Lean version of patientDocument (type alias of `patient`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { patient } from "../models"
 * import { patientObject } from "../interfaces/mongoose.gen.ts"
 *
 * const patientObject: patientObject = patient.toObject();
 * ```
 */
export type patientObject = patient;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type patientQuery = mongoose.Query<
  any,
  patientDocument,
  patientQueries
> &
  patientQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `patientSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type patientQueries = {};

export type patientMethods = {};

export type patientStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const patient = mongoose.model<patientDocument, patientModel>("patient", patientSchema);
 * ```
 */
export type patientModel = mongoose.Model<patientDocument, patientQueries> &
  patientStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new patient schema instances:
 * ```
 * const patientSchema: patientSchema = new mongoose.Schema({ ... })
 * ```
 */
export type patientSchema = mongoose.Schema<
  patientDocument,
  patientModel,
  patientMethods,
  patientQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const patient = mongoose.model<patientDocument, patientModel>("patient", patientSchema);
 * ```
 */
export type patientNameDocument = mongoose.Document<mongoose.Types.ObjectId> & {
  _id: {
    type: {};
  };
  prefix?: string;
  first: string;
  middle?: string;
  last: string;
  suffix?: string;
};

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const patient = mongoose.model<patientDocument, patientModel>("patient", patientSchema);
 * ```
 */
export type patientAdditional_dataDocument =
  mongoose.Document<mongoose.Types.ObjectId> & {
    _id: {
      type: {};
    };
    dob?: Date;
    pob?: string;
    address: {
      street: string;
      subdistrict: string;
      district: string;
      city: string;
      province?: string;
      zipcode?: string;
    };
    temporary_address: {
      street: string;
      subdistrict: string;
      district: string;
      city: string;
      province?: string;
      zipcode?: string;
    };
    contact: {
      name?: string;
      ssn?: string;
      relation?:
        | 'BAPAK'
        | 'IBU'
        | 'ANAK'
        | 'SAUDARA KANDUNG'
        | 'SUAMI'
        | 'ISTRI'
        | 'KAKEK'
        | 'NENEK'
        | 'KERABAT';
      email: string;
      phone_number: mongoose.Types.Array<string>;
    };
    emergency_contact: {
      name?: string;
      ssn?: string;
      relation?:
        | 'BAPAK'
        | 'IBU'
        | 'ANAK'
        | 'SAUDARA KANDUNG'
        | 'SUAMI'
        | 'ISTRI'
        | 'KAKEK'
        | 'NENEK'
        | 'KERABAT';
      email: string;
      phone_number: mongoose.Types.Array<string>;
    };
    status: {
      is_blacklisted: boolean;
      is_alive: boolean;
      deceased_at?: Date;
    };
    notes?: string;
    guarantor: guarantorDocument['_id'] | guarantorDocument;
    guarantor_no?: string;
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const patient = mongoose.model<patientDocument, patientModel>("patient", patientSchema);
 * ```
 */
export type patientDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  patientQueries
> &
  patientMethods & {
    mrn: string;
    ssn: string;
    religion:
      | 'ISLAM'
      | 'PROTESTAN'
      | 'KATHOLIK'
      | 'HINDU'
      | 'BUDDHA'
      | 'KHONGHUCU';
    occupation: string;
    education: string;
    marital_status: 'BELUM MENIKAH' | 'MENIKAH' | 'CERAI MATI' | 'CERAI HIDUP';
    created_at: Date;
    created_by: employeeDocument['_id'] | employeeDocument;
    updated_at?: Date;
    updated_by?: employeeDocument['_id'] | employeeDocument;
    _id: mongoose.Types.ObjectId;
    name: patientNameDocument;
    additional_data: patientAdditional_dataDocument;
  };

/**
 * Lean version of registrationCobGuarantorDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `registrationCobDocument.toObject()`.
 * ```
 * const registrationcobObject = registrationcob.toObject();
 * ```
 */
export type registrationCobGuarantor = {
  guarantor: guarantor['_id'] | guarantor;
  guarantor_no: string;
  method: 'PLAFON', 'CAKUPAN';
  plafond_amount?: string;
  _id: {
    type: {};
  };
};

/**
 * Lean version of registrationCobDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `registrationCobDocument.toObject()`. To avoid conflicts with model names, use the type alias `registrationCobObject`.
 * ```
 * const registrationcobObject = registrationcob.toObject();
 * ```
 */
export type registrationCob = {
  guarantors: registrationCobGuarantor[];
  created_at: Date;
  created_by: employee['_id'] | employee;
  updated_at?: Date;
  updated_by?: employee['_id'] | employee;
  _id: mongoose.Types.ObjectId;
};

/**
 * Lean version of registrationCobDocument (type alias of `registrationCob`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { registrationCob } from "../models"
 * import { registrationCobObject } from "../interfaces/mongoose.gen.ts"
 *
 * const registrationcobObject: registrationCobObject = registrationcob.toObject();
 * ```
 */
export type registrationCobObject = registrationCob;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type registrationCobQuery = mongoose.Query<
  any,
  registrationCobDocument,
  registrationCobQueries
> &
  registrationCobQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `registrationCobSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type registrationCobQueries = {};

export type registrationCobMethods = {};

export type registrationCobStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const registrationCob = mongoose.model<registrationCobDocument, registrationCobModel>("registrationCob", registrationCobSchema);
 * ```
 */
export type registrationCobModel = mongoose.Model<
  registrationCobDocument,
  registrationCobQueries
> &
  registrationCobStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new registrationCob schema instances:
 * ```
 * const registrationCobSchema: registrationCobSchema = new mongoose.Schema({ ... })
 * ```
 */
export type registrationCobSchema = mongoose.Schema<
  registrationCobDocument,
  registrationCobModel,
  registrationCobMethods,
  registrationCobQueries
>;

/**
 * Mongoose Subdocument type
 *
 * Type of `registrationCobDocument["guarantors"]` element.
 */
export type registrationCobGuarantorDocument = mongoose.Types.Subdocument & {
  guarantor: guarantorDocument['_id'] | guarantorDocument;
  guarantor_no: string;
  method: 'PLAFON, CAKUPAN';
  plafond_amount?: string;
  _id: {
    type: {};
  };
};

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const registrationCob = mongoose.model<registrationCobDocument, registrationCobModel>("registrationCob", registrationCobSchema);
 * ```
 */
export type registrationCobDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  registrationCobQueries
> &
  registrationCobMethods & {
    guarantors: mongoose.Types.DocumentArray<registrationCobGuarantorDocument>;
    created_at: Date;
    created_by: employeeDocument['_id'] | employeeDocument;
    updated_at?: Date;
    updated_by?: employeeDocument['_id'] | employeeDocument;
    _id: mongoose.Types.ObjectId;
  };

/**
 * Lean version of registrationService_timeDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `registrationDocument.toObject()`.
 * ```
 * const registrationObject = registration.toObject();
 * ```
 */
export type registrationService_time = {
  _id: {
    type: {};
  };
  arrived_at?: Date;
  confirmed_at?: Date;
  served_at?: Date;
  finished_at?: Date;
};

/**
 * Lean version of registrationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `registrationDocument.toObject()`. To avoid conflicts with model names, use the type alias `registrationObject`.
 * ```
 * const registrationObject = registration.toObject();
 * ```
 */
export type registration = {
  registration_no: string;
  appointment_no?: string;
  mrn: string;
  doctor: employee['_id'] | employee;
  unit: unit['_id'] | unit;
  time: string;
  que_no: string;
  date: Date;
  sep?: string;
  guarantor?: string;
  guarantor_no?: string;
  note?: string;
  referral_from?: string;
  cob?: registrationCob['_id'] | registrationCob;
  created_at: Date;
  created_by: employee['_id'] | employee;
  updated_at?: Date;
  updated_by?: employee['_id'] | employee;
  canceled_at?: Date;
  canceled_by?: employee['_id'] | employee;
  _id: mongoose.Types.ObjectId;
  service_time: registrationService_time;
};

/**
 * Lean version of registrationDocument (type alias of `registration`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { registration } from "../models"
 * import { registrationObject } from "../interfaces/mongoose.gen.ts"
 *
 * const registrationObject: registrationObject = registration.toObject();
 * ```
 */
export type registrationObject = registration;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type registrationQuery = mongoose.Query<
  any,
  registrationDocument,
  registrationQueries
> &
  registrationQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `registrationSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type registrationQueries = {};

export type registrationMethods = {};

export type registrationStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const registration = mongoose.model<registrationDocument, registrationModel>("registration", registrationSchema);
 * ```
 */
export type registrationModel = mongoose.Model<
  registrationDocument,
  registrationQueries
> &
  registrationStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new registration schema instances:
 * ```
 * const registrationSchema: registrationSchema = new mongoose.Schema({ ... })
 * ```
 */
export type registrationSchema = mongoose.Schema<
  registrationDocument,
  registrationModel,
  registrationMethods,
  registrationQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const registration = mongoose.model<registrationDocument, registrationModel>("registration", registrationSchema);
 * ```
 */
export type registrationService_timeDocument =
  mongoose.Document<mongoose.Types.ObjectId> & {
    _id: {
      type: {};
    };
    arrived_at?: Date;
    confirmed_at?: Date;
    served_at?: Date;
    finished_at?: Date;
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const registration = mongoose.model<registrationDocument, registrationModel>("registration", registrationSchema);
 * ```
 */
export type registrationDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  registrationQueries
> &
  registrationMethods & {
    registration_no: string;
    appointment_no?: string;
    mrn: string;
    doctor: employeeDocument['_id'] | employeeDocument;
    unit: unitDocument['_id'] | unitDocument;
    time: string;
    que_no: string;
    date: Date;
    sep?: string;
    guarantor?: string;
    guarantor_no?: string;
    note?: string;
    referral_from?: string;
    cob?: registrationCobDocument['_id'] | registrationCobDocument;
    created_at: Date;
    created_by: employeeDocument['_id'] | employeeDocument;
    updated_at?: Date;
    updated_by?: employeeDocument['_id'] | employeeDocument;
    canceled_at?: Date;
    canceled_by?: employeeDocument['_id'] | employeeDocument;
    _id: mongoose.Types.ObjectId;
    service_time: registrationService_timeDocument;
  };

/**
 * Lean version of unitLocationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `unitDocument.toObject()`.
 * ```
 * const unitObject = unit.toObject();
 * ```
 */
export type unitLocation = {
  _id: {
    type: {};
  };
  floor: string;
  number: string;
};

/**
 * Lean version of unitCapacityDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `unitDocument.toObject()`.
 * ```
 * const unitObject = unit.toObject();
 * ```
 */
export type unitCapacity = {
  total: number;
  filled: number;
  _id: {
    type: {};
  };
};

/**
 * Lean version of unitDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `unitDocument.toObject()`. To avoid conflicts with model names, use the type alias `unitObject`.
 * ```
 * const unitObject = unit.toObject();
 * ```
 */
export type unit = {
  entity: entity['_id'] | entity;
  name: {
    full: string;
    short: string;
  };
  type: 'KAMAR' | 'MEDIS' | 'NON-MEDIS' | 'DEPOT';
  belongs_to?: employee['_id'] | employee;
  status: 'TERSEDIA' | 'PEMELIHARAAN' | 'TIDAK TERSEDIA';
  created_at: Date;
  created_by: employee['_id'] | employee;
  updated_at?: Date;
  updated_by?: employee['_id'] | employee;
  _id: mongoose.Types.ObjectId;
  location: unitLocation;
  capacity: unitCapacity;
};

/**
 * Lean version of unitDocument (type alias of `unit`)
 *
 * Use this type alias to avoid conflicts with model names:
 * ```
 * import { unit } from "../models"
 * import { unitObject } from "../interfaces/mongoose.gen.ts"
 *
 * const unitObject: unitObject = unit.toObject();
 * ```
 */
export type unitObject = unit;

/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type unitQuery = mongoose.Query<any, unitDocument, unitQueries> &
  unitQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `unitSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type unitQueries = {};

export type unitMethods = {};

export type unitStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const unit = mongoose.model<unitDocument, unitModel>("unit", unitSchema);
 * ```
 */
export type unitModel = mongoose.Model<unitDocument, unitQueries> & unitStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new unit schema instances:
 * ```
 * const unitSchema: unitSchema = new mongoose.Schema({ ... })
 * ```
 */
export type unitSchema = mongoose.Schema<
  unitDocument,
  unitModel,
  unitMethods,
  unitQueries
>;

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const unit = mongoose.model<unitDocument, unitModel>("unit", unitSchema);
 * ```
 */
export type unitLocationDocument =
  mongoose.Document<mongoose.Types.ObjectId> & {
    _id: {
      type: {};
    };
    floor: string;
    number: string;
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const unit = mongoose.model<unitDocument, unitModel>("unit", unitSchema);
 * ```
 */
export type unitCapacityDocument =
  mongoose.Document<mongoose.Types.ObjectId> & {
    total: number;
    filled: number;
    _id: {
      type: {};
    };
  };

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const unit = mongoose.model<unitDocument, unitModel>("unit", unitSchema);
 * ```
 */
export type unitDocument = mongoose.Document<
  mongoose.Types.ObjectId,
  unitQueries
> &
  unitMethods & {
    entity: entityDocument['_id'] | entityDocument;
    name: {
      full: string;
      short: string;
    };
    type: 'KAMAR' | 'MEDIS' | 'NON-MEDIS' | 'DEPOT';
    belongs_to?: employeeDocument['_id'] | employeeDocument;
    status: 'TERSEDIA' | 'PEMELIHARAAN' | 'TIDAK TERSEDIA';
    created_at: Date;
    created_by: employeeDocument['_id'] | employeeDocument;
    updated_at?: Date;
    updated_by?: employeeDocument['_id'] | employeeDocument;
    _id: mongoose.Types.ObjectId;
    location: unitLocationDocument;
    capacity: unitCapacityDocument;
  };

/**
 * Check if a property on a document is populated:
 * ```
 * import { IsPopulated } from "../interfaces/mongoose.gen.ts"
 *
 * if (IsPopulated<UserDocument["bestFriend"]>) { ... }
 * ```
 */
export function IsPopulated<T>(doc: T | mongoose.Types.ObjectId): doc is T {
  return doc instanceof mongoose.Document;
}

/**
 * Helper type used by `PopulatedDocument`. Returns the parent property of a string
 * representing a nested property (i.e. `friend.user` -> `friend`)
 */
type ParentProperty<T> = T extends `${infer P}.${string}` ? P : never;

/**
 * Helper type used by `PopulatedDocument`. Returns the child property of a string
 * representing a nested property (i.e. `friend.user` -> `user`).
 */
type ChildProperty<T> = T extends `${string}.${infer C}` ? C : never;

/**
 * Helper type used by `PopulatedDocument`. Removes the `ObjectId` from the general union type generated
 * for ref documents (i.e. `mongoose.Types.ObjectId | UserDocument` -> `UserDocument`)
 */
type PopulatedProperty<Root, T extends keyof Root> = Omit<Root, T> & {
  [ref in T]: Root[T] extends mongoose.Types.Array<infer U>
    ? mongoose.Types.Array<Exclude<U, mongoose.Types.ObjectId>>
    : Exclude<Root[T], mongoose.Types.ObjectId>;
};

/**
 * Populate properties on a document type:
 * ```
 * import { PopulatedDocument } from "../interfaces/mongoose.gen.ts"
 *
 * function example(user: PopulatedDocument<UserDocument, "bestFriend">) {
 *   console.log(user.bestFriend._id) // typescript knows this is populated
 * }
 * ```
 */
export type PopulatedDocument<DocType, T> = T extends keyof DocType
  ? PopulatedProperty<DocType, T>
  : ParentProperty<T> extends keyof DocType
  ? Omit<DocType, ParentProperty<T>> & {
      [ref in ParentProperty<T>]: DocType[ParentProperty<T>] extends mongoose.Types.Array<
        infer U
      >
        ? mongoose.Types.Array<
            ChildProperty<T> extends keyof U
              ? PopulatedProperty<U, ChildProperty<T>>
              : PopulatedDocument<U, ChildProperty<T>>
          >
        : ChildProperty<T> extends keyof DocType[ParentProperty<T>]
        ? PopulatedProperty<DocType[ParentProperty<T>], ChildProperty<T>>
        : PopulatedDocument<DocType[ParentProperty<T>], ChildProperty<T>>;
    }
  : DocType;

/**
 * Helper types used by the populate overloads
 */
type Unarray<T> = T extends Array<infer U> ? U : T;
type Modify<T, R> = Omit<T, keyof R> & R;

/**
 * Augment mongoose with Query.populate overloads
 */
declare module 'mongoose' {
  interface Query<ResultType, DocType, THelpers = {}> {
    populate<T extends string>(
      path: T,
      select?: string | any,
      model?: string | Model<any, THelpers>,
      match?: any,
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers;

    populate<T extends string>(
      options: Modify<PopulateOptions, { path: T }> | Array<PopulateOptions>,
    ): Query<
      ResultType extends Array<DocType>
        ? Array<PopulatedDocument<Unarray<ResultType>, T>>
        : ResultType extends DocType
        ? PopulatedDocument<Unarray<ResultType>, T>
        : ResultType,
      DocType,
      THelpers
    > &
      THelpers;
  }
}
